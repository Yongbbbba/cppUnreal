#include <iostream>

using namespace std;

// 오늘의 주제 : 포인터 마무리
// 1) 포인터 vs 배열 2탄
// 2) 주의사항(마음가짐?)
// - 함수 안에서 만든 지역 변수를 포인터나 참조를 이용해서 반환하는 우를 범하지 말자. 스택 프레임의 생애주기를 생각해보면 말도안되는 일이라는 것을 알거다..

int main()
{ 
	// 주소를 담는 바구니
	// 진퉁은 저~ 멀리 어디간게 있음
	// p는 단지 그곳으로 워프하는 포탈
	int* p;

	// 진짜배기! 원조 데이터
	// 닭장처럼 데이터의 묶음(엄청 많고 거대함)
	int arr[10];

	//  둘은 엄밀히 다른건데 상당히 많은 사람들이 [배열 = 포인터]라 착각하는 경향이 있음!
	// - 이는 [배열의 이름]이 배열의 시작 주소값을 가리키는 포인터처럼 쓰이기 때문에 발생하는 오해
	// - [배열의 이름]은 배열의 시작 주소값을 가리키는 TYPE* 포인터로 변환가능!
	p = arr;

	// - [TYPE형 1차원 배열]과 [TYPE*형 포인터]는 완전히 호환이 된다
	cout << p[0] << endl;
	cout << arr[0] << endl;
	cout << p[5] << endl;
	cout << arr[5] << endl;

	cout << *p << endl;
	cout << *arr << endl;  // arr[0]
	cout << *(p + 3) << endl;
	cout << *(arr + 3) << endl; 

	// 지옥을 보여드리겠습니다. (2차원 배열 vs 다중 포인터)

	// [1][2][3][4]  메모리 까보면 2차원이 아니라 나란히 할당되어있음.
	int arr2[2][2] = { {1,2}, {3,4} };

	// 2차원 배열과 다중 포인터는 호환되지 않는 현상
	// 
	// 주소2[ ] << 4바이트
	// 주소1[ 주소2]  -> 이럴거라고 예상했지만 실제로 메모리 확인해보면 주소1[ 00000001 ] 
	// pp[ 주소1 ] 
	// int** pp = (int**)arr2;

	// TYPE name[개수]
	int a[10];

	// [ 1 ][ 2 ]
	// [ 주소 ]
	int(*p2)[2] = arr2;  // int가 두 개인 배열을 가리키는 포인터, 실무에서 이거 쓰는 일은 거의 없을거임.. 연습문제에서나 사용
	cout << (*p2)[0] << endl;
	cout << (*p2)[1] << endl;
	cout << (*(p2 + 1)[0]) << endl;
	cout << (*(p2+ 1 ))[1] << endl;
	cout << endl;
	cout << p2[0][0] << endl;
	cout << p2[0][1] << endl;
	cout << p2[1][0] << endl;
	cout << p2[1][1] << endl;

	return 0;
}

