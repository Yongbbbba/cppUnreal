#include <iostream>
using namespace std;

// 오늘의 주제 : 동적 할당

// 메모리 구조 복습
// - 실행할 코드가 저장되는 영역 -> 코드 영역
// - 전역(global)/정적(static) 변수 -> 데이터 영역
// - 지역 변수/매개 변수 -> 스택 영역
// - 동적 할당 -> 힙 영역 
// 
// 지금까지 데이터 영역/스택 영역 이용해서
// 이런 저런 프로그램을 잘 만들어 왔다!
// 굳이 새로운 영역이 필요할까?

// 실제 상황)
// - MMORPG 동접 1명~5만명, 몬스터 1마리~500만마리
// - 몬스터 생성 이벤트 > 5분 동안 몬스터가 10배 많이 나옴 

// 위 상황을 지금까지 배운 것을 가지고 적당하게 해결할 수 있나? 

// - 스택 영역
// -- 함수가 끝나면 같이 정리되는 불안정한 메모리
// -- 잠시 함수에 매개변수 넘긴다거나 하는 용도로는 OK
// 
// - 메모리 영역
// -- 프로그램이 실행되는 도중에는 '무조건' 사용되는 

// 희망사항) 
// - 필요할 때만 사용하고, 필요없으면 반납할 수 있는!
// - 그러면서도 (스택과는 다르게) 우리가 생성/소멸 시점을 관리할 수 있는!
// - 그런 아름다운 메모리 없나? ->  HEAP!! 
// 동적할당과 연관된 함수/연산자 : malloc, free, new, delete, new[], delete[]

// malloc
// - 할당할 메모리 크기를 건내준다
// - 메모리 할당 후 시작 주소를 가리키는 포인터를 반환해준다 (메모리 부족하면 NULL, 하지만 이런 일이 일어나는 상황이면 그전에 프로그램 뻗어버릴 확률이 큼) 

// free 
// - malloc (혹은 기타 calloc, realloc 등의 사촌) 을 통해 할당된 영역을 해제
// - 힙 관리자가 할당/미할당 여부를 구분해서 관리

class Monster
{
public:
	int _hp;
	int _x;
	int _y;
};

// Monster monster[500 * 10000];  이런 식으로 몬스터를 만들면.. 공간 낭비가 매우 심하다

int main()
{
	// 유저 영역 [메모장] [LOL] [곰플레이어] 
	// ---------------------------
	// 커널 영역(Windows 등의 핵심 코드가 실행되는 영역)

	// 유저 영역) 운영체제에서 제공하는 API 호출
	// 커널 영역) 메모리 할당해서 건내줌
	// 유저 영역) ㄳ ㄳ 잘 쓸게요 ~

	// 메모리가 필요할 때마다 매번 커널에 메모리 할당을 요청하면, 애플리케이션이 한 두개가 아니기 때문에 시스템 호출이 너무 자주 일어남
	// 그렇기 때문에 미리 큼지막한 영역을 구비해놓음

	// [                           메모리       할당                          ]
	// C++에서는 기본적으로 CRT(C런타임 라이브러리)의 [힙 관리자]를 통해 힙 영역 사용
	// 단, 정말 원한다면 우리가 직접 API를 통해 힙을 생성하고 관리할 수도 있음(MMORPG 서버 메모리 풀링)

	// 그런데 잠깐! void* ?? 무엇일까
	// *가 있으니까 포인터는 포인터 (주소를 담는 바구니) => OK 
	// 타고 가면 void 아무것도 없다? -> 그건 아니다 
	// 타고 가면 void 뭐가 있는지 모르겠으니까 너가 적당히 변환해서 사용해라  라는 뜻
	// void* pointer = malloc(1000);
	void* pointer = malloc(sizeof(Monster));

	Monster* m1 = (Monster*)pointer; // 사용 용도에 맞게 형변환해서 사용
	m1->_hp = 100;

	// Heap overflow
	// - 유효한 힙 범위를 초과해서 사용하는 문제

	free(pointer);  // 할당받았던 메모리 영역을 다 사용했으면 해제시켜줘야함
	
	// 만약 free를 안해준다면..? 아무런 위화감없이 프로그램은 실행된다
	// -> 하지만 메모리 누수 현상이 일어남. 계속 메모리를 갉아먹어서 나중에 메모리 여유분이 없어서 프로그램이 뻗는 경우가 생긴다
	
	// 만약 free를 여러 번 해준다면...?
	// Double Free 
	// - 이건 대부분 그냥 크래시만 나고 끝난다

	// Use-After-Free 
	// 반납했으면 쓰지 말아야 하는데.. 쓰는 경우. 메모리는 해제되었어도 pointer라는 변수는 살아있으니깐.
	// 이렇게 해버리면 바로 크래시가 나면 그나마 다행인데, 아무 관련없는 값을 건드리게 되면 큰일. 
	// 예를 들어 다른 사람의 골드를 건드린다거나.. 이것이 C++이 다루기 어려운 언어인 이유이자 강점
	// - 프로그래머 입장 : OMG 망했다!
	// - 해커 입장 : 심봤다! 

	// 이런 실수를 막기 위해서 해제한 포인터에는 nullptr를 넣어주면 좋음 
	pointer = nullptr;
	m1 = nullptr;


	return 0;
}