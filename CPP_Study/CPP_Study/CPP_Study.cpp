#include <iostream>

using namespace std;

// 오늘의 주제 : 불리언과 실수

// [NOTE]
// 사실 bool은 그냥 1바이트 정수에 불과 
// 어셈블리에서는 bool이라는 것은 없음
// bool은 1바이트의 정수인데, 왜 굳이 1바이트까지 할당했을까? al 레지스터와 같이 레지스터의 최소 단위가 1바이트이기 때문에 boolean도 1 바이트를 잡아놨다고 보는 것이 합당하다.

// 실수 (부동소수점)
// float double
// 3.14
// 쩜 앞/뒤를 기준으로 16/16씩 나눠서 표현하는 것이 어떨까? -> 생각보다 표현할 수 있는 수가 크지 않음
// (0~65535) . (0~65535)
// 부동 소수점
// .을 유동적으로 움직여서 표현하는 방법
// 1) 정규화 = 0.31415926435 * 10
// 2) 31415926435 (유효숫자) 1 (지수)

// float 부호(1비트) 지수(8비트) 유효숫자(23비트) = 32비트 = 4바이트
// double 부호(1) 지수(11) 유효숫자(52) = 62비트 = 8바이트 


float attackSpeed = -3.375f; // 4바이트
double attackSpeed2 = 123.4123; // 8바이트
// ex) -3.375라는 값을 저장
// 1) 2진수 변환 = (3) + (0.375) = 0b11 + 0b0.011 = 0b11.011
// 0.375 = 0.5 * 0 + 0.25 * 1 + 0.125 *  1 = 0b0.011
// 2) 정규화 0b1.1011 * 2^1
// 1(부호) 1(지수) 1011(유효숫자)
// 단 지수는 unsigned byte라고 가정하고 숫자 + 127 만들어줌
// 예상 결과 : 0b 1 10000000 1011000 0000 0000 0000 0000
// 가장 중요한 것은 프로그래밍할 때 부동소수점은 항상 '근사값'이라는 것을 기억해야함
// 특히 수가 커질 수록 오차 범위도 매우 커짐
// 실수 2개를 == 으로 비교하는 것은 지양

int main()
{
	cout << attackSpeed << endl;
}

