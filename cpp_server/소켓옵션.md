소켓에도 여러 옵션을 줄 수 있음. 자세한 것은 msdn 참고. 

setsockopt()로 옵션을 주고, getsockopt()로 옵션을 확인할 수 있음.

	// 옵션을 해석하고 처리할 주체?
	// 소켓 코드 -> SOL_SOCKET
	// IPv4 -> IPPRTO_IP
	// TCP 프로토콜 -> IPPROTO_TCP 

```c++
// SO_REUSEADDR
// IP 주소 및 port 재사용
{
    bool enable = true;
    ::setsockopt(serverSocket, SOL_SOCKET, SO_REUSEADDR, (Char*)&enable, sizeof(enable));
}
```



```c++
// SO_SNDBUF = 송신 버퍼 크기 
// SO_RCVBUF = 수신 버퍼 크기 
int32 sendBufferSize;
int32 optionLen = sizeof(sedBufferSize);
::getsockopt(serverSocket, SOL_SOCKET, SO_SNDBUF, (char*)&sendbufferSize, &optionLen);
cout << "송신 버퍼 크기 : " << sendBufferSize << endl;

int32 recvBufferSize;
optionLen = sizeof(recvBufferSize);
::getsockopt(serverSocket, SOL_SOCKET, SO_SNDBUF, (char*)&recvBufferSize, &optionLen);
cout << "수신 버퍼 크기 : " << recvBufferSize << endl;
```



```c++
// IPPOROTO_TCP
// TCP_NODELAY = Nagle 네이글 알고리즘 작동 여부
// 데이터가 충분히 크면 보내고, 그렇지 않으면 데이터가 충분히 쌓일 때가지 대기! 
// 최대한 데이터를 뭉쳐보내서 회선 낭비를 최소화.
// 장점 : 작은 패킷이 불필요하게 많이 생성되는 일을 방지
// 단점 : 반응 시간 손해
// 게임에서는 네이글을 꺼두는 것이 일반적.
// 패킷을 보내고말고는 유저 레벨에서 조절할 수 있기 때문에 우리가 관리하는 것이 좋다.
{
    bool enable = true;;
    ::setsockopt(serverSocekt, IPPROTO_TCP, TCP_NODELAY, (char*)&enable, sizeof(enable));
}
```

